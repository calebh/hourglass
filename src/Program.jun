module Program
open(Prelude, Constants)

type mode = setting
          | timing
          | paused
          | finale

type flip = flipUp
          | flipDown
          | flipFlat

let accState : maybe<Accelerometer:orientation> ref = ref nothing<Accelerometer:orientation>()
let modeState : mode ref = ref setting()

let timeRemaining : int32 ref = ref 0
let totalTime : int32 ref = ref 0

fun setup() : unit =
    Time:wait(500)

fun clearDisplay() : unit =
    for i : uint16 in 0 to numLeds - 1 do
        FastLed:setLedColor(i, blank, leds)
    end

fun main() : unit = (
    setup();
    while true do (
        clearDisplay();
        // Grab the current accelerometer data
        // Drop repeats is used so we only get the changes in orientation
        let accSig = Signal:dropRepeats<Accelerometer:orientation>(Accelerometer:getSignal(), accState);
        let flipSig =
            Signal:map<Accelerometer:orientation, flip>(
                fn (o : Accelerometer:orientation) : flip ->
                    case o of
                    | Accelerometer:xUp() => flipUp()
                    | Accelerometer:xDown() => flipDown()
                    | _  => flipFlat()
                    end, accSig);
        // Use the meta function since we cleared the display
        // at the start of the loop. We need to call the execute
        // functions for every tick
        let metaFlipSig = SignalExt:meta<flip>(flipSig);
        // Determine the next mode using a state machine
        let modeSig =
            Signal:foldP<maybe<flip>, mode>(
                fn (f1 : maybe<flip>, prevMode : mode) : mode ->
                    // Time is up! Go to the finale
                    if (prevMode == timing()) and (!timeRemaining <= 0) then
                        finale()
                    else
                        case f1 of
                        | just<flip>(f2 : flip) =>
                            // There is a flip event on the metaFlipSig
                            case (f2, prevMode) of
                            | (flipUp(), setting()) => (
                                set ref totalTime = !timeRemaining;
                                Timing:reset();
                                timing())
                            | (flipUp(),   paused())  => timing()
                            | (flipDown(), timing())  => (Setting:reset(timeRemaining); setting())
                            | (flipDown(), paused())  => (Setting:reset(timeRemaining); setting())
                            | (flipFlat(), timing())  => paused()
                            | (flipDown(),   finale())  => (Setting:reset(timeRemaining); setting())
                            | _ => prevMode
                            end
                        | _ =>
                            // There wasn't a flip event on the metaFlipSig
                            prevMode
                        end
                    end, modeState, metaFlipSig);
        Signal:sink<mode>(fn (m : mode) : unit ->
            // Now execute some specific part of the signal graph
            // based on the current mode
            case m of
            | setting() => Setting:execute(timeRemaining)
            | timing() => Timing:execute(timeRemaining, !totalTime)
            | paused() => Paused:execute(timeRemaining, !totalTime)
            | finale() => Finale:execute()
            end, modeSig);
        FastLed:show()
    ) end
)
